阻塞，非阻塞，同步，异步

网络IO阶段一
    数据准备:(在(TCP接收内核缓冲区)没有准备好数据,线程会发生阻塞)
    阻塞： 掉用IO 方法的线程进入阻塞状态
    int size = recv(sockfd, buf, 1024,0)
    sockfd: 默认是阻塞的,(可以处理成非阻塞sockfd)
    如果当前sockfd 没有数据可读，会造成当前线程阻塞,就是一直阻塞,直到这个sockfd,有数据到来
    如果将sockfd 设置为非阻塞，则没数据就不会造成线程阻塞（相当于没有数据准备好的情况下他会空转CPU）
    size == -1 && EAGAIN            非阻塞返回,连接没问题，但没有数据到来（返回的原因是非阻塞IO造成的）       
    size == 0                       网路对端关闭了连接
    size > 0                        读取了多少数据

    非阻塞：不会改变线程的状态，通过返回值判断


网路IO阶段二:
    数据读写:
        IO 的同步和异步(操作系统层面):
            同步：recv(fd,buf,1024,0)这个方法中，将内核缓冲区中的数据同步到buf中

            异步：sockfd 有数据接收，操作系统直接放入buf中,并且发送信号sigio 通知发送完毕
        并发的同步和异步(业务层面):


Reactor 模型：
    Event:

    Reactor:
    
    Demultiplex:

    EventHandler:
1 格式：
20240601 1234  微秒   
时间戳字符串中的日期和时间用于缓存的，一秒之内的多条日志需要重新格式化
